// use std::str::FromStr;
use crate::ast::{AstNode,Term};
use crate::tok::Tok;

grammar<'input>(input: &'input str);


pub Iris: Vec<AstNode> = {
    <s:TopLevel*> => s,
};

TopLevel: AstNode = {
    <f:FnDef> => f,
    // <x:Assign> ";" => x,
    // <x:IfStmt> => x,
    // <e:Expr> ";" => e,
};

// CommaSep<T>: Vec<T> = { // (1)
//     <e:T> <v:("," <T>)*> => { // (2)
//         let mut ret = vec![e];
//         let mut v = v;
//         ret.append(&mut v);
//         ret
//     }
// }

// FnDefArgs = CommaSep<Ident>;
FnBodyStmt: AstNode = {
    <t:TopLevel> => t,
    <x:Return> => x,
}
FnDef: AstNode = {
    "fn" <name:Ident> "(" <args:Ident*> RParen ")" Crlf <body: FnBodyStmt*> RCurlyBracket => AstNode::FnDef {
        name,
        args: match args {
            Some(a) => a,
            None => vec![],
        },
        body,
    }
}

// TODO: runtime to support anonymous fn defs
// AnonymousFnDef: AstNode = {
//     Fn LParen <args:FnDefArgs?> RParen LCurlyBracket <body: FnBodyStmt*> RCurlyBracket => AstNode::FnDef {
//         name: "anon".to_string(),
//         args: match args {
//             Some(a) => a,
//             None => vec![],
//         },
//         body,
//     }
// }

// Assign: AstNode = {
//     <ident:Ident> "=" <e:Expr> => AstNode::Assignment(
//         Term::Ident(ident),
//         Box::new(e),
//     )
// }

// ReturnStmt: AstNode = {
//     "return" <e:Expr> => AstNode::Return(Box::new(e)),
// }

// ElseIf: AstNode = {
//     "elif" "(" <cond_expr:Expr> ")" "{" <body: FnBodyStmt*> "}" => AstNode::ElseIf {
//         cond_expr: Box::new(cond_expr),
//         body,
//     }
// }
// ElseBlock: Vec<AstNode> = {
//     "else" "{" <body: FnBodyStmt*> "}" => body,
// }
// IfStmt: AstNode = {
//     "if" "(" <cond_expr:Expr> ")" "{" <body: FnBodyStmt*> "}" <else_if:ElseIf*> <else_body:ElseBlock?> => AstNode::If {
//         cond_expr: Box::new(cond_expr),
//         body,
//         else_if,
//         else_body: match else_body {
//             Some(b) => b,
//             None => vec![],
//         }
//     }
// }

// Expr: AstNode = {
//     <f:FnCall> => f,
//     // <a:AnonymousFnDef> => a,
//     <l:ListLiteral> => l,
//     <t:Term> => t,
// }

// Term: AstNode = {
//     <n:Int> => AstNode::Term(Term::Integer(n)),
//     <x:Ident> => AstNode::Term(Term::Ident(x)),
//     <b:Bool> => AstNode::Term(Term::Bool(b)),
//     <s:Str> => AstNode::Term(Term::Str(s)),
//     "(" <t:Term> ")" => t,
// }

// FnCallArgs = CommaSep<Expr>; // (0)
// FnCall: AstNode = {
//     <name:Ident> "(" <maybe_args:FnCallArgs?> ")" => {
//         AstNode::FnCall{
//             name,
//             args: match maybe_args {
//                 Some(a) => a,
//                 None => vec![],
//             }
//         }
//     }
// }


// ListLiteral: AstNode = {
//     "[" <v:CommaSep<Expr>> "]" => AstNode::FnCall{
//         name: "list".to_string(),
//         args: v,
//     }
// }

Bool: bool = {
    True => true,
    False => false,
}

Ident: String = {
    // TODO: Don't copy string, leave as reference for better memory usage
    <i:Ident> => i.to_string(),
}

Int: i32 = {
    <i:IntTok> Crlf? => match i {
        Tok::Number(a) => a,
        _ => unreachable!(),
    }
}

Str: String = {
    <s:SingleLiteralString> => s[1..s.len()-1].to_string(),
    <s:DoubleLiteralString> => s[1..s.len()-1].to_string(),
}

Dot = { "." Crlf? };
Equals = { "=" Crlf? };
Plus = { "+" Crlf? };
Minus = { "-" Crlf? };
ForwardSlash = { "/" Crlf? };
Star = { "*" Crlf? };
GreaterThan = { ">" Crlf? };
LessThan = { "<" Crlf? };
Ampersand = { "&" Crlf? };
BitwiseOr = { "|" Crlf? };
LParen = { "(" Crlf? };
RParen = { ")" Crlf? };
LCurlyBracket = { "{" Crlf? };
RCurlyBracket = { "}" Crlf? };
LBracket = { "[" Crlf? };
RBracket = { "]" Crlf? };
Caret = { "^" Crlf? };
Modulo = { "%" Crlf? };
Exclamation = { "!" Crlf? };
Tilde = { "~" Crlf? };
Comma = { "," Crlf? };
Semicolon = { ";" Crlf? };
DoubleEquals = { "==" Crlf? };
GreaterThanEqual = { ">=" Crlf? };
LessThanEqual = { "<=" Crlf? };
ShiftLeft = { "<<" Crlf? };
ShiftRight = { ">>" Crlf? };
Exponent = { "**" Crlf? };
Arrow = { "->" Crlf? };
True = { "true" Crlf? };
False = { "false" Crlf? };
If = { "if" Crlf? };
Else = { "else" Crlf? };
Elif = { "elif" Crlf? };
Fn = { "fn" Crlf? };
Return = { "return" Crlf? };
While = { "while" Crlf? };
For = { "for" Crlf? };
In = { "in" Crlf? };
Let = { "let" Crlf? };
Break = { "break" Crlf? };
Continue = { "continue" Crlf? };
Match = { "match" Crlf? };
Enum = { "enum" Crlf? };
Struct = { "struct" Crlf? };
And = { "and" Crlf? };
Or = { "or" Crlf? };
Not = { "not" Crlf? };
// Ident = { IdentTok Crlf? };
// Int = { Int Crlf? };


extern {
    type Location = usize;
    type Error = ();

    enum Tok<'input> {
        "." => Tok::Dot,
        "=" => Tok::Equals,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "/" => Tok::ForwardSlash,
        "*" => Tok::Star,
        ">" => Tok::GreaterThan,
        "<" => Tok::LessThan,
        "&" => Tok::Ampersand,
        "|" => Tok::BitwiseOr,
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "{" => Tok::LCurlyBracket,
        "}" => Tok::RCurlyBracket,
        "[" => Tok::LBracket,
        "]" => Tok::RBracket,
        "^" => Tok::Caret,
        "%" => Tok::Modulo,
        "!" => Tok::Exclamation,
        "~" => Tok::Tilde,
        "," => Tok::Comma,
        ";" => Tok::Semicolon,
        "==" => Tok::DoubleEquals,
        ">=" => Tok::GreaterThanEqual,
        "<=" => Tok::LessThanEqual,
        "<<" => Tok::ShiftLeft,
        ">>" => Tok::ShiftRight,
        "**" => Tok::Exponent,
        "->" => Tok::Arrow,
        "true" => Tok::True,
        "false" => Tok::False,
        "if" => Tok::If,
        "else" => Tok::Else,
        "elif" => Tok::Elif,
        "fn" => Tok::Fn,
        "return" => Tok::Return,
        "while" => Tok::While,
        "for" => Tok::For,
        "in" => Tok::In,
        "let" => Tok::Let,
        "break" => Tok::Break,
        "continue" => Tok::Continue,
        "match" => Tok::Match,
        "enum" => Tok::Enum,
        "struct" => Tok::Struct,
        "and" => Tok::And,
        "or" => Tok::Or,
        "not" => Tok::Not,
        SingleLiteralString => Tok::SingleLiteralString(<&'input str>),
        DoubleLiteralString => Tok::DoubleLiteralString(<&'input str>),
        IdentTok => Tok::Ident(<&'input str>),
        Crlf => Tok::Crlf,
        IntTok => Tok::Number(i32),
    }
}