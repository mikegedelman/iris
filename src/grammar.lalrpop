// use std::str::FromStr;
use crate::ast::{AstNode,Term};
use crate::tok::Tok;

grammar<'input>(input: &'input str);


pub Iris: Vec<AstNode> = {
    Crlf* <s:TopLevel*> => s,
};


TopLevel: AstNode = {
    <s:Statement> Crlf+ => s,
};

Statement: AstNode = {
    <f:FnDef> => f,
    <x:VarDeclaration> => x,
    <x:Assignment> => x,
    // <x:IfStmt> => x,
    <e:Expr> => e,
}

Comma<T>: Vec<T> = { // (1)
    <e:T> <v:("," Crlf* <T>)*> => { // (2)
        let mut ret = vec![e];
        let mut v = v;
        ret.append(&mut v);
        ret
    }
}

Expr: AstNode = {
    <f:FnCall> => f,
    <l:ListLiteral> => l,
    <a:AnonymousFnDef> => a,
    <i:IfStmt> => i,
    <d:DotOp> => d,
    <t:Term> => t,
}

DotOp: AstNode = {
    <e:Expr> "." <ast_fn:FnCall> => match ast_fn {
        AstNode::FnCall{ name, args } => {
            let mut new_args = args;
            new_args.insert(0, e);
            // A way to do this immutably?
            // let mut new_args = vec![e];
            // new_args.append(args);
            AstNode::FnCall {
                name,
                args: new_args,
            }
        },
        _ => unreachable!(),
    }
}

FnDefArgs = Comma<Ident>;
FnBodyStmt: AstNode = {
    <s:Statement> Crlf+ => s,
    // <x:Return> Crlf => x,
}
OneLineFnDef: AstNode = {
    "fn" <name:Ident> "(" <args:FnDefArgs?> ")" <body: Expr> "end" => AstNode::FnDef {
        name,
        args: match args {
            Some(a) => a,
            None => vec![],
        },
        body: vec![body],
    }
}
MultiLineFnDef: AstNode = {
    "fn" <name:Ident> "(" <args:FnDefArgs?> ")" Crlf+ <body: FnBodyStmt*> "end" => AstNode::FnDef {
        name,
        args: match args {
            Some(a) => a,
            None => vec![],
        },
        body,
    }
}
FnDef: AstNode = {
    <x:OneLineFnDef> => x,
    <x:MultiLineFnDef> => x,
}

// TODO: runtime to support anonymous fn defs
OneLineAnonymousFnDef: AstNode = {
    "fn" "(" <args:FnDefArgs?> ")" <body: Expr> "end" => AstNode::FnDef {
        name: "anon".to_string(),
        args: match args {
            Some(a) => a,
            None => vec![],
        },
        body: vec![body],
    }
}
MultiLineAnonymousFnDef: AstNode = {
    "fn" "(" <args:FnDefArgs?> ")" Crlf+ <body: FnBodyStmt*> "end" => AstNode::FnDef {
        name: "anon".to_string(),
        args: match args {
            Some(a) => a,
            None => vec![],
        },
        body,
    }
}
AnonymousFnDef: AstNode = {
    <x:OneLineAnonymousFnDef> => x,
    <x:MultiLineAnonymousFnDef> => x,
}

VarDeclaration: AstNode = {
    "let" <ident:Ident> "=" <e:Expr> => AstNode::VarDeclaration(
        Term::Ident(ident),
        Box::new(e),
    )
}
Assignment: AstNode = {
    <ident:Ident> "=" <e:Expr> => AstNode::Assignment(
        Term::Ident(ident),
        Box::new(e),
    )
}

// Return: AstNode = {
//     "return" <e:Expr> => AstNode::Return(Box::new(e)),
// }


OneLineElse: AstNode = { "else" <else_body:Expr> => else_body }
OneLineIfStmt: AstNode = {
    "if" <cond_expr:Expr> "then" <body: Expr> <else_body:OneLineElse?> "end"  => AstNode::If {
        cond_expr: Box::new(cond_expr),
        body: vec![body],
        else_if: vec![],
        else_body: match else_body {
            Some(b) => vec![b],
            None => vec![],
        }
    }
}

ElseIf: AstNode = {
    "elif" <cond_expr:Expr> "then" Crlf+ <body: FnBodyStmt*> => AstNode::ElseIf {
        cond_expr: Box::new(cond_expr),
        body,
    }
}
Else: Vec<AstNode> = {
    "else" Crlf+ <body: FnBodyStmt*> => body,
}

MultiLineIfStmt: AstNode = {
    "if" <cond_expr:Expr> "then" Crlf+ <body: FnBodyStmt*> <else_if:ElseIf*> <else_body:Else?> "end"  => AstNode::If {
        cond_expr: Box::new(cond_expr),
        body,
        else_if,
        else_body: match else_body {
            Some(b) => b,
            None => vec![],
        }
    }
}
IfStmt: AstNode = {
    <x:OneLineIfStmt> => x,
    <x:MultiLineIfStmt> => x,
}



Term: AstNode = {
    <n:Int> => AstNode::Term(Term::Integer(n)),
    <x:Ident> => AstNode::Term(Term::Ident(x)),
    <b:Bool> => AstNode::Term(Term::Bool(b)),
    <s:Str> => AstNode::Term(Term::Str(s)),
    "(" <t:Term> ")" => t,
}

FnCallArgs = Comma<Expr>; // (0)
FnCall: AstNode = {
    <name:Ident> "(" <maybe_args:FnCallArgs?> ")" => {
        AstNode::FnCall{
            name,
            args: match maybe_args {
                Some(a) => a,
                None => vec![],
            }
        }
    }
}

ListLiteral: AstNode = {
    "[" <v:Comma<Expr>> "]" => AstNode::FnCall{
        name: "list".to_string(),
        args: v,
    }
}


Bool: bool = {
    "true" => true,
    "false" => false,
}

Ident: String = {
    // TODO: Don't copy string, leave as reference for better memory usage
    <i:IdentTok> => i.to_string(),
}

Int: i32 = {
    <i:IntTok> => match i {
        Tok::Number(a) => a,
        _ => unreachable!(),
    }
}

Str: String = {
    <s:SingleLiteralString> => s[1..s.len()-1].to_string(),
    <s:DoubleLiteralString> => s[1..s.len()-1].to_string(),
}


extern {
    type Location = usize;
    type Error = ();

    enum Tok<'input> {
        "." => Tok::Dot,
        "=" => Tok::Equals,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "/" => Tok::ForwardSlash,
        "*" => Tok::Star,
        ">" => Tok::GreaterThan,
        "<" => Tok::LessThan,
        "&" => Tok::Ampersand,
        "|" => Tok::BitwiseOr,
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "{" => Tok::LCurlyBracket,
        "}" => Tok::RCurlyBracket,
        "[" => Tok::LBracket,
        "]" => Tok::RBracket,
        "^" => Tok::Caret,
        "%" => Tok::Modulo,
        "!" => Tok::Exclamation,
        "~" => Tok::Tilde,
        "," => Tok::Comma,
        ";" => Tok::Semicolon,
        "==" => Tok::DoubleEquals,
        ">=" => Tok::GreaterThanEqual,
        "<=" => Tok::LessThanEqual,
        "<<" => Tok::ShiftLeft,
        ">>" => Tok::ShiftRight,
        "**" => Tok::Exponent,
        "->" => Tok::Arrow,
        "true" => Tok::True,
        "false" => Tok::False,
        "if" => Tok::If,
        "else" => Tok::Else,
        "elif" => Tok::Elif,
        "fn" => Tok::Fn,
        "return" => Tok::Return,
        "while" => Tok::While,
        "for" => Tok::For,
        "in" => Tok::In,
        "let" => Tok::Let,
        "break" => Tok::Break,
        "continue" => Tok::Continue,
        "match" => Tok::Match,
        "enum" => Tok::Enum,
        "struct" => Tok::Struct,
        "and" => Tok::And,
        "or" => Tok::Or,
        "not" => Tok::Not,
        "end" => Tok::End,
        "then" => Tok::Then,
        SingleLiteralString => Tok::SingleLiteralString(<&'input str>),
        DoubleLiteralString => Tok::DoubleLiteralString(<&'input str>),
        IdentTok => Tok::Ident(<&'input str>),
        Crlf => Tok::Crlf,
        IntTok => Tok::Number(i32),
    }
}